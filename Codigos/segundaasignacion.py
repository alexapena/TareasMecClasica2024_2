# -*- coding: utf-8 -*-
"""Finales.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qj02NcTDwnm5pgJT-czv83Tg6zJMhNuC
"""

import numpy as np
import matplotlib.pyplot as plt
import math

# Definir parámetros constantes
K = 1        # Constante que está en el documento
r = 1        # Distancia r

b_values = [0.0000001, 0.0000005, 0.000001]  # Distintos valores del parámetro de impacto
alpha_values = [10, 5, 0]  # Tres valores diferentes de alpha
alpha_labels = ['alpha = 10', 'alpha = 5', 'alpha = 0']  # Etiquetas para alpha

# Definir un rango de energías
E = np.linspace(0.1, 80000, 5000)  # Energía de 0.1 a 10000

# Función para el ángulo de dispersión
def theta_dispersion(E, b, K, alpha, r):
    return 2 * ((np.pi / 2) - np.arctan((2 * b * E) / (K * np.exp(-alpha * r))))

# Estilos de línea para cada valor de alpha
line_styles = {
    10: 'dashed',    # Punteada para alpha = 10
    5: 'dotted',     # Círculos para alpha = 5
    0: '-'           # Línea continua para alpha = 0
}

# Graficar
plt.figure(figsize=(10, 7))

# Variable para rastrear si hemos agregado la etiqueta de alpha
first_alpha = True

# Iterar sobre los diferentes valores de alpha y graficar para cada uno
for alpha in alpha_values:
    # Agregar una etiqueta solo para el primer valor de b con alpha correspondiente
    for idx, b in enumerate(b_values):
        theta = theta_dispersion(E, b, K, alpha, r)
        # Añadir el valor de alpha como primera etiqueta del grupo y luego los valores de b
        if idx == 0:
            label = f'{alpha_labels[alpha_values.index(alpha)]}\nb = {b:.1e}'
        else:
            label = f'b = {b:.1e}'
        plt.plot(E, np.degrees(theta), label=label, linestyle=line_styles[alpha])  # Aplicar estilo de línea

# Etiquetas y título
plt.xlabel('Energía (julios)')
plt.ylabel('Ángulo de dispersión (θ) [grados]')
plt.title(f'Ángulo de dispersión vs Energía para diferentes valores de alpha y b (r = {r})')

# Ajustar la leyenda para que muestre los valores como lista bajo cada alpha
plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1))
plt.grid(True)

# Mostrar gráfica
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import math

# Definir parámetros constantes
K = 1        # Constante que está en el documento
b_value = 0.000001  # Valor fijo del parámetro de impacto
r_values = [1, 0.8, 0.6]  # Distintos valores de r
alpha_values = [10, 5, 0]  # Tres valores diferentes de alpha
alpha_labels = ['alpha = 10', 'alpha = 5', 'alpha = 0']  # Etiquetas para alpha

# Definir un rango de energías
E = np.linspace(0.1, 8000, 5000)  # Energía de 0.1 a 10000

# Función para el ángulo de dispersión
def theta_dispersion(E, b, K, alpha, r):
    return 2 * ((np.pi / 2) - np.arctan((2 * b * E) / (K * np.exp(-alpha * r))))

# Estilos de línea para cada valor de alpha
line_styles = {
    10: 'dashed',    # Punteada para alpha = 10
    5: 'dotted',     # Círculos para alpha = 5
    0: '-'           # Línea continua para alpha = 0
}

# Graficar
plt.figure(figsize=(10, 7))

# Iterar sobre los diferentes valores de alpha y graficar para cada uno
for alpha in alpha_values:
    for idx, r in enumerate(r_values):
        theta = theta_dispersion(E, b_value, K, alpha, r)
        # Añadir el valor de alpha en la primera línea y los valores de r en las siguientes
        if idx == 0:
            label = f'{alpha_labels[alpha_values.index(alpha)]}\nr = {r}m'
        else:
            label = f'r = {r}m'
        plt.plot(E, np.degrees(theta), label=label, linestyle=line_styles[alpha])  # Aplicar estilo de línea

# Etiquetas y título
plt.xlabel('Energía (julios)')
plt.ylabel('Ángulo de dispersión (θ) [grados]')
plt.title('Ángulo de dispersión vs Energía para diferentes valores de alpha y r (b=1e-6)')

# Ajustar la leyenda para que muestre los valores como lista bajo cada alpha
plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1))
plt.grid(True)

# Mostrar gráfica
plt.tight_layout()
plt.show()

"""#Aca otras cosas mi gente"""

import numpy as np
import matplotlib.pyplot as plt

# Definir parámetros constantes
K = 1  # Constante que está en el documento
r = 1  # Distancia r fija

E_values = [2000, 20000, 200000, 2000000]  # Distintos valores de energía
alpha_values = [10, 5, 0]  # Tres valores de alpha

# Definir un rango para el parámetro de impacto
b = np.linspace(0.0000000000000001, 0.00000001, 500)  # Valores de b entre 0.1 y 5

# Función para el ángulo de dispersión
def theta_dispersion(E, b, K, alpha, r):
    return 2 * ((np.pi / 2) - np.arctan((2*b*E)/(K * np.exp(-alpha * r))))

# Estilos de línea para cada valor de alpha
line_styles = {
    10: 'dashed',    # Punteada para alpha = 10
    5: 'dotted',     # Círculos para alpha = 5
    0: '-'           # Línea continua para alpha = 0
}

# Graficar
plt.figure(figsize=(10, 7))

# Iterar sobre los diferentes valores de alpha
for alpha in alpha_values:
    # Graficar para diferentes valores de E con notación científica
    for idx, E in enumerate(E_values):
        theta = theta_dispersion(E, b, K, alpha, r)
        # Añadir el valor de alpha en la primera línea y los valores de E en las siguientes
        if idx == 0:
            label = f'alpha = {alpha}\nE = {E:.0e} J'
        else:
            label = f'E = {E:.0e} J'
        plt.plot(b, np.degrees(theta), label=label, linestyle=line_styles[alpha])  # Aplicar estilo de línea

# Etiquetas y título
plt.xlabel('Parámetro de impacto (b)')
plt.ylabel('Ángulo de dispersión (θ) [grados]')
plt.title('Ángulo de dispersión vs Parámetro de impacto para diferentes valores de alpha y de energía (r = 1m)')

# Formatear solo el eje x en notación científica
plt.ticklabel_format(style='sci', axis='x', scilimits=(0, 0))

# Asegurarse de que el eje y no tenga notación científica (grados normales)
plt.gca().get_yaxis().get_major_formatter().set_useOffset(False)
plt.gca().get_yaxis().get_major_formatter().set_scientific(False)

# Ajustar la leyenda para que muestre los valores como lista bajo cada alpha
plt.legend(loc='upper right', bbox_to_anchor=(1.35, 1))
plt.grid(True)

# Mostrar gráfica
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Definir parámetros constantes
K = 1  # Constante que está en el documento
E = 2000  # Energía fija
r_values = [1, 0.8, 0.6]  # Distintos valores de r
alpha_values = [10, 5, 0]  # Tres valores de alpha

# Definir un rango para el parámetro de impacto
b = np.linspace(0.000000000001, 0.000001, 10000)  # Valores de b entre 1e-17 y 1e-8

# Función para el ángulo de dispersión
def theta_dispersion(E, b, K, alpha, r):
    return 2 * ((np.pi / 2) - np.arctan((2 * b * E) / (K * np.exp(-alpha * r))))

# Estilos de línea para cada valor de alpha
line_styles = {
    10: 'dashed',    # Punteada para alpha = 10
    5: 'dotted',     # Círculos para alpha = 5
    0: '-'           # Línea continua para alpha = 0
}

# Graficar
plt.figure(figsize=(10, 7))

# Iterar sobre los diferentes valores de alpha
for alpha in alpha_values:
    # Graficar para diferentes valores de r
    for idx, r in enumerate(r_values):
        theta = theta_dispersion(E, b, K, alpha, r)
        # Añadir el valor de alpha en la primera línea y los valores de r en las siguientes
        if idx == 0:
            label = f'alpha = {alpha}\nr = {r}m'
        else:
            label = f'r = {r}m'
        plt.plot(b, np.degrees(theta), label=label, linestyle=line_styles[alpha])  # Convertir a grados y aplicar estilo de línea

# Etiquetas y título
plt.xlabel('Parámetro de impacto (b)')
plt.ylabel('Ángulo de dispersión (θ) [grados]')
plt.title(f'Ángulo de dispersión vs Parámetro de impacto para diferentes valores de alpha y r (E = {E:.0e} J)')

# Formatear solo el eje x en notación científica
plt.ticklabel_format(style='sci', axis='x', scilimits=(0, 0))

# Asegurarse de que el eje y no tenga notación científica (grados normales)
plt.gca().get_yaxis().get_major_formatter().set_useOffset(False)
plt.gca().get_yaxis().get_major_formatter().set_scientific(False)

# Ajustar la leyenda para que muestre los valores como lista bajo cada alpha
plt.legend(loc='upper right', bbox_to_anchor=(1.35, 1))
plt.grid(True)

# Mostrar gráfica
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# parámetros y el rango de ángulos
E = 1  # Energía de la partícula
k = 1  # cte coulomb
r = 1  # Radio
theta = np.linspace(0.01, np.pi, 500)  # Ángulo de dispersión (0 a pi, evitando cero)

# Función para la sección transversal diferencial
def seccion_transversal(theta, alpha):
    sin_term = np.sin(theta / 2)**4
    exp_term = np.exp(-2 * alpha * r)
    prefactor = (k / (4 * E))**2
    return prefactor * exp_term / sin_term

# Valores de alpha a graficar
alpha_values = [-2, -1.5, -1, -0.5, 0.5, 1, 1.5, 2]

#Sección transversal diferencial vs el ángulo de apantallamiento para varios valores de alpha
plt.figure(figsize=(8, 6))

for alpha in alpha_values:
    sigma = seccion_transversal(theta, alpha)
    plt.plot(np.degrees(theta), sigma, label=f'alpha = {alpha}')

# Ajustes del gráfico
plt.yscale('log')  # Escala logarítmica en el eje Y
plt.xlabel(r'Ángulo de dispersión $\theta$ (grados)')
plt.ylabel(r'Sección transversal diferencial($\frac{d\sigma}{d\Omega}$) ')
plt.title('Sección transversal diferencial vs Ángulo de dispersión para distintos valores de alpha')
plt.legend()
plt.grid(True)
plt.show()

